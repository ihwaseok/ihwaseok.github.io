---
title: 개요
updated: 2022-12-23 05:59:54Z
created: 2022-12-16 09:17:44Z
latitude: 37.26357270
longitude: 127.02860090
altitude: 0.0000
---

<b style="font-size:30px">[Java 8](https://devdocs.io/openjdk~8/)</b> &nbsp;&nbsp;(이전버전 포함)

---

## 람다 표현식
- <abbr title="메소드를 하나만 가지는 인터페이스">함수형 인터페이스</abbr>를 구현한 객체
 → 매개 변수만을 사용하도록 만든 함수로 외부 자료에 부수적인 영향이 발생하지 않도록 함
 → 외부에 영향을 미치지 않으므로 병렬 처리등에 가능 
 → 안정적인 확장성 있는 프로그래밍 방식
- 클래스를 호출하지 않고 함수의 호출만으로 기능을 수행
- 익명객체를 이용하여 수행됨
- 함수형 인터페이스 생성시 @FunctionalInterface 어노테이션을 사용
- `(파라미터 목록) -> { 람다식 바디 }`
- 파라미터가 1개면 () 생략 가능하고 메소드 참조 ::를 이용하여 표현 가능
```java
Runnable r = new Runnable() {
	public void run() {
		System.out.println("Howdy, world!");
	}
};
```
<font size="10">&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; ↓</font>
```java
Runnable r = () -> System.out.println("Howdy, world!");
```
```java
// 람다를 이용한 컬렉션 순회
List<String> list = new ArrayList();
list.add("Element1");
list.add("Element2");
list.add("Element3");

list.forEach(x -> System.out.println(x)) // forEach(System.out::println) 과 동일
```
<br>

## 스트림
- 컬렉션, 배열 등에 저장되어있는 요소들을 하나씩 참조하며 반복적인 처리를 가능하게 하는 기능
- 원본 데이터 자체를 변경하지 않는다
-  한 번 사용하면 닫혀서 재사용 불가능
 → 일회용
-  작업을 내부 반복으로 처리 
  → 반복문이 노출되지 않음
- Stream 생성 = 컬렉션, 배열, 파일, 람다식 등의 데이터 소스에서 생성
- 중개연산 = Stream을 전달받아 Stream을 반환하는 연산 (필터링, 변환, 제한, 정렬...)
- 최종연산 = 중개연산으로 만들어진 Stream의 각 요소들을 소모하여 최종결과 표시 (수집, 출력, 검색, 검사, 통계, 연산...)
- `배열.Stream생성().중개연산().최종연산()`
```java
// iterate를 이용하여 Stream생성
Stream<Integer> iteratedStream = Stream.iterate(30, n -> n + 2).limit(5); // [30, 32, 34, 36, 38]

// Stream내의 String을 대문자로 변환
Stream<String> stream = names.stream().map(String::toUpperCase); // map(x -> x.toUpperCase())와 동일

// Stream의 개수 반환
long count = IntStream.of(1, 3, 5, 7, 9).count();

// JPA로 가져온 Entity를 Dto로 변환
public List<TestDto> findTestList(TestDto testDto) {
	return testRepository.findAll().stream()
			.map(testEntity -> new TestDto(testEntity))
			.collect(Collectors.toList());
}
```
<br>

## 비교 및 조작이 용이한 날짜, 시간 API
- LocalDate = 날짜
- LocalTime = 시간
- LocalDateTime = 날짜와 시간
- ZonedDateTime = 특정 타임존의 날짜와 시간
- Instant = 특정 시점의 시간표기 클래스 (두 시점간의 시간적 우선순위)
```java
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM");
LocalDate startDate = LocalDate.parse("2022-12-23");

String M0 = startDate.format(formatter);		// 12
String M1 = startDate.plusMonths(1).format(formatter);	// 01
String M2 = startDate.plusMonths(2).format(formatter);	// 02

LocalDate today = LocalDate.now();	// 2022-12-23
today = today.minusMonths(8);		// 2022-04-23
LocalDate startDT = LocalDate.of(today.getYear(), today.getMonth(), 1);	// 2022-04-01
today = today.plusMonths(12);		// 2023-04-23
LocalDate endDT = LocalDate.of(today.getYear(), today.getMonth(), 1);	// 2023-04-01
endDT = endDT.minusDays(1);		// 2023-03-31
```
<br>

## 인터페이스 사용가능 키워드 추가
- 인터페이스에서 메소드에 default 키워드를 추가하면 구현부를 선언 가능
 → 인터페이스를 구현하는 클래스에서 메소드가 이름만 있고 구현부가 비어있는 경우를 줄일 수 있음 (구현 필요 없음)
 → 인터페이스는 여러개를 구현 가능한 점을 이용해 다중 상속 가능
- static 메소드 선언 가능
 → 호출은 `Interface이름.메소드` 으로 가능
```java
public interface Vehicle {
    public default void doSomething() {
        System.out.println("doSomething(Vehicle)");
    }
}
public static class Car implements Vehicle {
	public static void main(String args[]) {
		Car car = new Car();
		car.doSomething(); // doSomething(Vehicle) 출력
	}
}
```
<br>

## 옵셔널
- null이 될 수도 있는 객체를 감싸고 있는 일종의 래퍼 클래스
- null 처리를 쉽게 가능
```java
public String getCityOfMemberFromOrder(Order order) {
	if (order != null) {
		Member member = order.getMember();
		if (member != null) {
			Address address = member.getAddress();
			if (address != null) {
				String city = address.getCity();
				if (city != null) {
					return city;
				}
			}
		}
	}
	return "Seoul"; // default
}
```
<font size="10">&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; ↓</font>
```java
public String getCityOfMemberFromOrder(Order order) {
	return Optional.ofNullable(order)
			.map(Order::getMember)	
			.map(Member::getAddress)	
			.map(Address::getCity)		
			.orElse("Seoul");
}
```
<br>

## 이전 버전
|명칭|설명|
|--|--|
|리플렉션|구체적인 클래스 타입을 알지 못해도 그 클래스에 접근할 수 있도록 해주는 API|
|익명 클래스|일시적으로 한번만 사용되고 버려지는 객체 (~$.class)|
|정규 표현식|특정한 규칙을 가진 문자열의 집합을 표시하는데 사용되는 언어|
|XML API|XML파일 처리 API|
|제네릭|클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법|
|어노테이션|컴파일과 실행 과정에서 코드를 어떻게 처리해야하는지 알려주는 메타데이터|
|박싱/언박싱|원시타입을 참조타입(Wrapper)으로 바꾸는 것 / 참조타입을 원시타입으로 바꾸는 것|
|Enumeration|순환 인터페이스 (삭제 기능없는 Iterator)|
|가변 파라미터|메소드에서 동적으로 매개변수를 받는 것|
|static import|메소드나 변수를 패키지, 클래스명 없이 접근 가능|
|Concurrency API|동기화가 필요한 상황에서 쓸 수 있는 유틸리티 클래스 제공|
|Java Compiler API|javac 컴파일러 도구에 액세스 할 수 있는 API|
|Try-With-Resources|명시적으로 close()쓰지 않아도 자동으로 자원을 해제|
|숫자에 _ 지원|가독성을 위해 숫자에 _ 붙일 수 있도록 지원|
|File NIO|File 새로운 입출력(New Input/Output) 지원|

![788f9a4f22728b9c81368534b2bf083b.png](../../../../_resources/788f9a4f22728b9c81368534b2bf083b.png)