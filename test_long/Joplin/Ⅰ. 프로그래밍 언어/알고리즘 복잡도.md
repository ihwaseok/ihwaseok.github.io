---
title: 알고리즘 복잡도
updated: 2022-12-19 07:40:16Z
created: 2022-12-19 06:57:31Z
latitude: 37.24108640
longitude: 127.17755370
altitude: 0.0000
---

## 시간 복잡도
- 알고리즘의 수행 시간을 평가
 → 기본연산의 실행 횟수로 평가
- 일반적으로 빅오 표기법으로 표현
<br>

## 공간 복잡도
- 알고리즘에서 사용하는 메모리의 양을 평가
- 일반적으로 빅오 표기법으로 표현
<br>

## O(n) : 빅오 표기법
- 최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림
- T(n) = n<sup>2</sup> + 2n + 1 ▶ O(n<sup>2</sup>)
  → 가장 큰 입력크기 n<sup>2</sup>만 표기 (최고 차항만 표현)
- T(n) = 2n ▶ O(n)
 → 큰 차이가 없기 때문에 최고 차항의 계수는 제외
<br>

## O(1) : 상수 시간
- 입력크기에 상관없이 일정한 연산 수행
```java
// n=10 일때, 1번 실행됨
void test(int n) {
	System.out.println();
}
```
<br>

## O(log N) : 로그 시간
- 입력크기가 커질때 연산 횟수가 logN에 비례해서 증가
- 이진 탐색의 경우
```java
// n=10 일때, 5번 실행됨
for (int i=1; i <= n; i*2) {
	System.out.println();
}
```
<br>

## O(n) : 선형 시간
- 입력크기가 커질때 연산 횟수가 n에 비례해서 증가
```java
// n=10 일때, 10번 실행됨
for (int i=1; i <= n; i++) {
	System.out.println();
}
```
<br>

## O(n<sup>2</sup>) : 2차 시간
- 입력크기가 커질때 연산 횟수가 n<sup>2</sup>에 비례해서 증가
- 이중 반복문의 경우
```java
// n=10 일때, 100번 실행됨
for (int i=1; i <= n; i++) {
	for (int j=1; j <= n; j++) {
		System.out.println();	
	}
}
```
<br>

## O(2<sup>n</sup>) : 지수 시간
- 입력크기가 커질때 연산 횟수가 2<sup>n</sup>에 비례해서 증가
- 재귀 함수에서 반환을 2개씩 할 경우 
```java
// 피보나치의 수 로직 : 1, 1, 2, 3, 5, 8
// n=10 일때, 1024번 실행됨 : n → (n-1, n-2) → ((n-2, n-3), (n-3, n-4)) → ...
int test(int n) {
	
	if (n <= 1) {
		return n;
	}
	
	return test(n-1) + test(n-2);
}
```
<br>

![02a0741486b16101f6bb72f007f63361.png](../_resources/02a0741486b16101f6bb72f007f63361.png)