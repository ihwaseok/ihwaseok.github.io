---
title: 쿼리 성능
updated: 2023-01-20 07:35:09Z
created: 2023-01-20 07:35:03Z
latitude: 37.44491680
longitude: 127.13886840
altitude: 0.0000
sidebar: mydoc_sidebar1
permalink: Ⅰ.=프로그래밍=언어_03.=SQL_1.=ANSI=SQL_쿼리=성능.html
folder: mydoc
---

## 인덱스 컬럼으로 테이블 데이터 줄이기
- `WHERE`에서 인덱스 컬럼을 사용하면 인덱스 스캔이 적용되어 속도가 향상된다
<br>

## 필요한 컬럼만 가져오기
- \* 를 사용하여 모든 컬럼을 가져오면 불필요한 자원이 소모된다
<br>

## 테이블 참조와 데이터 개수는 가능한 적게 유지
- 조인 사용을 최소화 하여 테이블 접근을 적게 해야한다
- `WHERE`조건을 잘 사용하여 테이블에서 가능한 적은 데이터를 가져와야 한다
<br>

## LIKE 사용시 앞에 % 붙이지 않기
- 앞에 \%를 붙이면 검색 효율이 낮아진다
  → 인덱스 스캔이 적용되지 않는다
  → 포함된 모든 단어를 검색하게 된다

## IN 보다 EXISTS 사용
- 실행순서 상 `EXISTS`가 유리하다
	- `IN` = `IN 쿼리` → `메인 쿼리`
	- `EXISTS` = `메인 쿼리` → `EXISTS 쿼리`
- `IN`은 조건을 모든 `IN 결과`에 비교 대입하고 종료된다
- `EXISTS`는 조건을 만족하는 `EXISTS 결과`가 하나라도 발견되면 종료된다
<br>

## UNION 보다 UNION ALL 사용
- 중복을 제거하는 과정에서 모든 행에 접근하기 때문에 속도가 느리다
- 자동으로 정렬이 되기 때문에 속도가 느리다
<br>

## 삭제할 데이터가 더 많은 경우 DROP 사용
- `DELETE`보다 `DROP`이 더 빠르게 실행된다
- 단, 복구가 불가능하기 때문에 사용시 주의 필요
<br>

## 테이블 JOIN 시 인덱스 컬럼 사용
- 조인 사용시 인덱스 컬럼을 사용하면 인덱스 스캔으로 적용된다
<br>

## 가능한 INNER JOIN 사용
- `OUTTER 조인`보다 `INNER JOIN`이 성능상 유리하다
<br>

## HAVING 보다 WHERE 사용으로 데이터 개수 줄이기
- 실행순서 상 `WHERE`가 빠르다
- `HAVING`은 집계함수로 밖에 조건을 줄 수 없다
<br>

## NOT 사용 최소화
- 부정형 조건은 인덱스 스캔이 적용되지 않는다
- 부정형은 긍정형 보다 옵티마이저에서 처리량이 많다
<br>

## IS NULL 사용 최소화
- `NULL`조건은 인덱스 스캔이 적용되지 않는다
<br>

## 테이블 중복 접근 최소화
- 하나의 쿼리에서 같은 테이블은 가능한 한번의 접근으로 필요한 데이터를 찾아야 한다
<br>

## SELECT 에서 테이블 참조 최소화
- `SELECT`에서 사용되는 서브 쿼리는 메인쿼리의 행 개수만큼 반복된다
<br>

## 정렬 사용 최소화
- 정렬은 모든 데이터에 접근해야 하기 때문에 시간이 오래 걸린다
- 필요한 경우 가능하면 인덱스 컬럼을 사용하여 정렬
<br>

## 조건절에 함수 사용 최소화
- 함수를 사용하여 컬럼을 변형시키면 인덱스 스캔이 적용되지 않는다
<br>

## 임시테이블 사용 최소화
- 임시테이블 생성 시 메모리를 점유하게 되기 때문에 가능한 적게 사용해야 한다
<br>

## 입출력 요청 최소화
- 입출력 요청은 대부분의 쿼리보다 많은 시간이 걸리기 때문에 한번의 쿼리로 필요한 데이터를 가져와야 한다
<br>

## 통계정보 최신화
- 쿼리가 갑자기 느려지는 경우 테이블의 통계정보를 최신화 해야 한다
